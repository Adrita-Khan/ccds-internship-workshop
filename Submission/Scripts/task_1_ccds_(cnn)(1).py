# -*- coding: utf-8 -*-
"""Task 1 CCDS (CNN)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aMwC_wp4sKsc7QSw0EiDXFpO9-3V5ArP

Implement CNN code for the specified architecture, execute the model, generate training and validation loss curves, perform testing, and produce the confusion matrix along with evaluation metrics.![image.png](data:image/png;base64,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)
"""

import os

import matplotlib.pyplot as plt
import torch
import torch.nn as nn
import tqdm
import yaml
from sklearn.metrics import (ConfusionMatrixDisplay, classification_report,
                             confusion_matrix)
from torchvision import transforms
from torchvision.io import read_image

!wget https://github.com/ccdsiub/deeplearning-code-management/raw/1.1/CIFAR-10.zip
!wget https://github.com/ccdsiub/deeplearning-code-management/raw/1.1/configs/CNN_config.yaml
!unzip -q CIFAR-10.zip -d .

file = open("CNN_config.yaml")
config = yaml.safe_load(file)
file.close()
print(config)

class CIFAR10(torch.utils.data.Dataset):
    """The CIFAR10 dataset"""

    def __init__(self, root, transform=None, target_transform=None) -> None:
        """
        Initialize the CIFAR10 dataset

        :param root: The root directory of the dataset
        :type root: str
        :param transform: The transform to apply to the data
        :type transform: callable
        :param target_transform: The transform to apply to the target
        :type target_transform: callable

        :return: None
        :rtype: None
        """
        self.root = root
        self.transform = transform
        self.target_transform = target_transform
        self.data = []
        self.targets = []

        self._load_data()

    def _load_data(self):
        """
        Load the data from the root directory

        :return: None
        :rtype: None
        """
        # Load the data
        classes = os.listdir(self.root)
        classes.sort()
        for i, class_name in enumerate(classes):
            class_dir = os.path.join(self.root, class_name)
            for image_name in os.listdir(class_dir):
                image_path = os.path.join(class_dir, image_name)
                image = read_image(image_path)
                self.data.append(image)
                self.targets.append(float(i))

    def __getitem__(self, index: int) -> tuple:
        """
        Get the item at the given index

        :param index: The index of the item
        :type index: int

        :return: The item at the given index
        :rtype: tuple
        """
        img, target = self.data[index], self.targets[index]

        if self.transform is not None:
            img = self.transform(img)

        if self.target_transform is not None:
            target = self.target_transform(target)

        return img, target

    def __len__(self) -> int:
        """
        Get the length of the dataset

        :return: The length of the dataset
        :rtype: int
        """
        return len(self.data)

transform = transforms.Compose([
    transforms.ConvertImageDtype(torch.float32),
    transforms.Normalize((0.485, 0.456, 0.406), (0.229, 0.224, 0.225)),
])

# you can transform the target too if you want (e.g. one hot encode)
target_transform = transforms.Lambda(
    lambda y: torch.tensor(y, dtype=torch.long))

data_path = config["data_params"]["data_path"]
classes = os.listdir(data_path)
classes.sort()

dataset = CIFAR10(data_path, transform=transform,
                  target_transform=target_transform)

# dataset = ImageFolder(data_path, transform=transform,
#  target_transform=target_transform)

train_size = config["data_params"]["train_ratio"]
test_size = (1 - train_size) / 2
val_size = test_size

train_dataset, test_dataset, val_dataset = torch.utils.data.random_split(
    dataset, [train_size, test_size, val_size])

print(f"Train size: {len(train_dataset)}")
print(f"Test size: {len(test_dataset)}")
print(f"Validation size: {len(val_dataset)}")

train_loader = torch.utils.data.DataLoader(
    train_dataset,
    batch_size=config["data_params"]["batch_size"],
    num_workers=torch.get_num_threads(),
    shuffle=True
)

test_loader = torch.utils.data.DataLoader(
    test_dataset,
    batch_size=config["data_params"]["batch_size"],
    num_workers=torch.get_num_threads(),
    shuffle=False
)

val_loader = torch.utils.data.DataLoader(
    val_dataset,
    batch_size=config["data_params"]["batch_size"],
    num_workers=torch.get_num_threads(),
    shuffle=True
)

class Cifar10CnnModel(nn.Module):
    """The CIFAR10 CNN model"""

    def __init__(self, output_size: int) -> None:
        """
        Initialize the CIFAR10 CNN model

        :param output_size: The output size
        :type output_size: int
        """
        super().__init__()
        self.network = nn.Sequential(
            nn.Conv2d(3, 32, kernel_size=3, padding=1),
            nn.ReLU(),
            nn.Conv2d(32, 64, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(2, 2),  # output: 64 x 16 x 16

            nn.Conv2d(64, 128, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.Conv2d(128, 128, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(2, 2),  # output: 128 x 8 x 8

            nn.Conv2d(128, 256, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.Conv2d(256, 256, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(2, 2),  # output: 256 x 4 x 4

            nn.Flatten(),
            nn.Linear(256*4*4, 1024),
            nn.ReLU(),
            nn.Linear(1024, 512),
            nn.ReLU(),
            nn.Linear(512, output_size))
        self._initialize_weights_()

    def _initialize_weights_(self):
      for layer in self.children():
        if isinstance(layer, nn.Linear):
          nn.init.xavier_uniform_(layer.weight)
          nn.init.zeros_(layer.bias)
        elif isinstance(layer, nn.Conv2d):
          nn.init.xavier_uniform_(layer.weight)
          nn.init.zeros_(layer.bias)

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        """
        Forward pass

        :param x: The input data
        :type x: torch.Tensor

        :return: The output
        :rtype: torch.Tensor
        """
        return self.network(x)

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

model = Cifar10CnnModel(
    config['model_params']['num_classes']
).to(device)

criterion = torch.nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(
    model.parameters(),
    lr=config["model_params"]["learning_rate"],
    # L2 regularization
    weight_decay=config["model_params"]["weight_decay"]
)
scheduler = torch.optim.lr_scheduler.StepLR(
    optimizer,
    step_size=config["model_params"]["step_size"],
    gamma=config["model_params"]["gamma"]
)

def validate(
    model,
    val_loader: torch.utils.data.DataLoader,
    criterion: torch.nn.Module,
    device: torch.device
) -> tuple:
    """
    Validate the model

    :param model: The model to validate
    :type model: torch.nn.Module
    :param val_loader: The validation loader
    :type val_loader: torch.utils.data.DataLoader
    :param criterion: The loss function
    :type criterion: torch.nn.Module
    :param device: The device to use
    :type device: torch.device

    :return: The loss, accuracy and predictions
    :rtype: tuple
    """
    model.eval()
    val_loss = 0.0
    correct = 0
    y_pred = []
    with torch.no_grad():
        for images, labels in val_loader:
            images, labels = images.to(device), labels.to(device)
            outputs = model(images)
            loss = criterion(outputs, labels)
            val_loss += loss.item()
            _, predicted = torch.max(outputs, 1)
            correct += (predicted == labels).sum().item()
            y_pred.extend(predicted.cpu().numpy())

    val_loss /= len(val_loader)
    accuracy = correct / len(y_pred)

    return val_loss, accuracy, y_pred

def train(
    model: torch.nn.Module,
    train_loader: torch.utils.data.DataLoader,
    val_loader: torch.utils.data.DataLoader,
    criterion: torch.nn.Module,
    optimizer: torch.optim.Optimizer,
    scheduler: torch.optim.lr_scheduler.StepLR,
    device: torch.device,
    num_epochs: int
) -> tuple:
    """
    Train the model

    :param model: The model to train
    :type model: torch.nn.Module
    :param train_loader: The training loader
    :type train_loader: torch.utils.data.DataLoader
    :param val_loader: The validation loader
    :type val_loader: torch.utils.data.DataLoader
    :param criterion: The loss function
    :type criterion: torch.nn.Module
    :param optimizer: The optimizer
    :type optimizer: torch.optim.Optimizer
    :param scheduler: The learning rate scheduler
    :type scheduler: torch.optim.lr_scheduler.StepLR
    :param device: The device to use
    :type device: torch.device
    :param num_epochs: The number of epochs
    :type num_epochs: int

    :return: The trained model and the training history
    :rtype: tuple
    """
    history = {
        "train_loss": [],
        "val_loss": [],
        "val_acc": []
    }
    best_acc = 0.0

    for epoch in range(num_epochs):
        model.train()
        train_loss = 0.0
        loop = tqdm.tqdm(enumerate(train_loader),
                         total=len(train_loader), leave=False)
        for i, (images, labels) in loop:
            images, labels = images.to(device), labels.to(device)
            optimizer.zero_grad()
            outputs = model(images)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()
            train_loss += loss.item()

            loop.set_description(f"Epoch [{epoch + 1}/{num_epochs}]")
            loop.set_postfix(loss=train_loss / (i + 1))

        train_loss /= len(train_loader)
        val_loss, val_acc, _ = validate(model, val_loader, criterion, device)
        history["train_loss"].append(train_loss)
        history["val_loss"].append(val_loss)
        history["val_acc"].append(val_acc)

        print(f"Epoch [{epoch + 1}/{num_epochs}]")
        print(f"Train loss: {train_loss:.4f}")
        print(f"Validation loss: {val_loss:.4f}")
        print(f"Validation accuracy: {val_acc:.2f}%")

        if val_acc > best_acc:
            best_acc = val_acc
            checkpoint = {
                "epoch": epoch + 1,
                "model": model.state_dict(),
                "optimizer": optimizer.state_dict(),
                "scheduler": scheduler.state_dict(),
                "history": history
            }
            torch.save(checkpoint, "checkpoint.pth")

        scheduler.step()

    return model, history

model, history = train(
    model,
    train_loader,
    val_loader,
    criterion,
    optimizer,
    scheduler,
    device,
    num_epochs=config["model_params"]["num_epochs"]
)

plt.plot(history["train_loss"], label="Train loss")
plt.plot(history["val_loss"], label="Validation loss")
plt.title("Loss curve")
plt.xlabel("Epoch")
plt.ylabel("Loss")
plt.legend()
plt.show()

model.load_state_dict(torch.load("checkpoint.pth")["model"])

_, _, y_pred = validate(model, test_loader, criterion, device)
y_test = [labels for _, labels in test_loader]
y_test = torch.cat(y_test).numpy()

disp = ConfusionMatrixDisplay(confusion_matrix=confusion_matrix(
    y_test, y_pred), display_labels=classes)
disp = disp.plot(xticks_rotation=45)
plt.title('Confusion Matrix Test Data')
plt.show()

print('\n\n')
print(classification_report(y_test, y_pred, target_names=classes))