# -*- coding: utf-8 -*-
"""Task 2 CCDS (CNN)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bA2RCSmDfBEPoQTxXKYazNefT_2kX8CV

Fully connected layers are typically followed by a sigmoid activation function. Add a sigmoid activation function after each linear layer and remove the ReLU function for the linear layers (Architecture 2).  

Run the code.  

Generate the train and validation loss curves.  

Evaluate the model by producing the confusion matrix and other evaluation metrics.
"""

import os

import matplotlib.pyplot as plt
import torch
import torch.nn as nn
import tqdm
import yaml
from sklearn.metrics import (ConfusionMatrixDisplay, classification_report,
                             confusion_matrix)
from torchvision import transforms
from torchvision.io import read_image

!wget https://github.com/ccdsiub/deeplearning-code-management/raw/1.1/CIFAR-10.zip
!wget https://github.com/ccdsiub/deeplearning-code-management/raw/1.1/configs/CNN_config.yaml
!unzip -q CIFAR-10.zip -d .

file = open("CNN_config.yaml")
config = yaml.safe_load(file)
file.close()
print(config)

class CIFAR10(torch.utils.data.Dataset):
    """The CIFAR10 dataset"""

    def __init__(self, root, transform=None, target_transform=None) -> None:
        """
        Initialize the CIFAR10 dataset

        :param root: The root directory of the dataset
        :type root: str
        :param transform: The transform to apply to the data
        :type transform: callable
        :param target_transform: The transform to apply to the target
        :type target_transform: callable

        :return: None
        :rtype: None
        """
        self.root = root
        self.transform = transform
        self.target_transform = target_transform
        self.data = []
        self.targets = []

        self._load_data()

    def _load_data(self):
        """
        Load the data from the root directory

        :return: None
        :rtype: None
        """
        # Load the data
        classes = os.listdir(self.root)
        classes.sort()
        for i, class_name in enumerate(classes):
            class_dir = os.path.join(self.root, class_name)
            for image_name in os.listdir(class_dir):
                image_path = os.path.join(class_dir, image_name)
                image = read_image(image_path)
                self.data.append(image)
                self.targets.append(float(i))

    def __getitem__(self, index: int) -> tuple:
        """
        Get the item at the given index

        :param index: The index of the item
        :type index: int

        :return: The item at the given index
        :rtype: tuple
        """
        img, target = self.data[index], self.targets[index]

        if self.transform is not None:
            img = self.transform(img)

        if self.target_transform is not None:
            target = self.target_transform(target)

        return img, target

    def __len__(self) -> int:
        """
        Get the length of the dataset

        :return: The length of the dataset
        :rtype: int
        """
        return len(self.data)

transform = transforms.Compose([
    transforms.ConvertImageDtype(torch.float32),
    transforms.Normalize((0.485, 0.456, 0.406), (0.229, 0.224, 0.225)),
])

# you can transform the target too if you want (e.g. one hot encode)
target_transform = transforms.Lambda(
    lambda y: torch.tensor(y, dtype=torch.long))

data_path = config["data_params"]["data_path"]
classes = os.listdir(data_path)
classes.sort()

dataset = CIFAR10(data_path, transform=transform,
                  target_transform=target_transform)

# dataset = ImageFolder(data_path, transform=transform,
#  target_transform=target_transform)

train_size = config["data_params"]["train_ratio"]
test_size = (1 - train_size) / 2
val_size = test_size

train_dataset, test_dataset, val_dataset = torch.utils.data.random_split(
    dataset, [train_size, test_size, val_size])

print(f"Train size: {len(train_dataset)}")
print(f"Test size: {len(test_dataset)}")
print(f"Validation size: {len(val_dataset)}")

train_loader = torch.utils.data.DataLoader(
    train_dataset,
    batch_size=config["data_params"]["batch_size"],
    num_workers=torch.get_num_threads(),
    shuffle=True
)

test_loader = torch.utils.data.DataLoader(
    test_dataset,
    batch_size=config["data_params"]["batch_size"],
    num_workers=torch.get_num_threads(),
    shuffle=False
)

val_loader = torch.utils.data.DataLoader(
    val_dataset,
    batch_size=config["data_params"]["batch_size"],
    num_workers=torch.get_num_threads(),
    shuffle=True
)

class Cifar10CnnModel(nn.Module):
    """The CIFAR10 CNN model"""

    def __init__(self, output_size: int) -> None:
        """
        Initialize the CIFAR10 CNN model

        :param output_size: The number of output classes
        :type output_size: int
        """
        super().__init__()
        self.network = nn.Sequential(
            # First Convolutional Block
            nn.Conv2d(3, 32, kernel_size=3, padding=1),
            nn.ReLU(),
            nn.Conv2d(32, 64, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(2, 2),  # Output: 64 x 16 x 16

            # Second Convolutional Block
            nn.Conv2d(64, 128, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.Conv2d(128, 128, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(2, 2),  # Output: 128 x 8 x 8

            # Third Convolutional Block
            nn.Conv2d(128, 256, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.Conv2d(256, 256, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(2, 2),  # Output: 256 x 4 x 4

            # Flatten and Fully Connected Layers
            nn.Flatten(),
            nn.Linear(256*4*4, 1024),
            nn.Sigmoid(),          # Replaced ReLU with Sigmoid
            nn.Linear(1024, 512),
            nn.Sigmoid(),          # Replaced ReLU with Sigmoid
            nn.Linear(512, output_size)
            # Note: Typically, no activation here if using CrossEntropyLoss
        )
        self._initialize_weights_()

    def _initialize_weights_(self):
        for layer in self.network:
            if isinstance(layer, nn.Linear):
                nn.init.xavier_uniform_(layer.weight)
                nn.init.zeros_(layer.bias)
            elif isinstance(layer, nn.Conv2d):
                nn.init.xavier_uniform_(layer.weight)
                nn.init.zeros_(layer.bias)

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        """
        Forward pass of the network.

        :param x: Input tensor
        :type x: torch.Tensor
        :return: Output tensor
        :rtype: torch.Tensor
        """
        return self.network(x)

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

model = Cifar10CnnModel(
    config['model_params']['num_classes']
).to(device)

criterion = torch.nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(
    model.parameters(),
    lr=config["model_params"]["learning_rate"],
    # L2 regularization
    weight_decay=config["model_params"]["weight_decay"]
)
scheduler = torch.optim.lr_scheduler.StepLR(
    optimizer,
    step_size=config["model_params"]["step_size"],
    gamma=config["model_params"]["gamma"]
)

def validate(
    model,
    val_loader: torch.utils.data.DataLoader,
    criterion: torch.nn.Module,
    device: torch.device
) -> tuple:
    """
    Validate the model

    :param model: The model to validate
    :type model: torch.nn.Module
    :param val_loader: The validation loader
    :type val_loader: torch.utils.data.DataLoader
    :param criterion: The loss function
    :type criterion: torch.nn.Module
    :param device: The device to use
    :type device: torch.device

    :return: The loss, accuracy and predictions
    :rtype: tuple
    """
    model.eval()
    val_loss = 0.0
    correct = 0
    y_pred = []
    with torch.no_grad():
        for images, labels in val_loader:
            images, labels = images.to(device), labels.to(device)
            outputs = model(images)
            loss = criterion(outputs, labels)
            val_loss += loss.item()
            _, predicted = torch.max(outputs, 1)
            correct += (predicted == labels).sum().item()
            y_pred.extend(predicted.cpu().numpy())

    val_loss /= len(val_loader)
    accuracy = correct / len(y_pred)

    return val_loss, accuracy, y_pred

def train(
    model: torch.nn.Module,
    train_loader: torch.utils.data.DataLoader,
    val_loader: torch.utils.data.DataLoader,
    criterion: torch.nn.Module,
    optimizer: torch.optim.Optimizer,
    scheduler: torch.optim.lr_scheduler.StepLR,
    device: torch.device,
    num_epochs: int
) -> tuple:
    """
    Train the model

    :param model: The model to train
    :type model: torch.nn.Module
    :param train_loader: The training loader
    :type train_loader: torch.utils.data.DataLoader
    :param val_loader: The validation loader
    :type val_loader: torch.utils.data.DataLoader
    :param criterion: The loss function
    :type criterion: torch.nn.Module
    :param optimizer: The optimizer
    :type optimizer: torch.optim.Optimizer
    :param scheduler: The learning rate scheduler
    :type scheduler: torch.optim.lr_scheduler.StepLR
    :param device: The device to use
    :type device: torch.device
    :param num_epochs: The number of epochs
    :type num_epochs: int

    :return: The trained model and the training history
    :rtype: tuple
    """
    history = {
        "train_loss": [],
        "val_loss": [],
        "val_acc": []
    }
    best_acc = 0.0

    for epoch in range(num_epochs):
        model.train()
        train_loss = 0.0
        loop = tqdm.tqdm(enumerate(train_loader),
                         total=len(train_loader), leave=False)
        for i, (images, labels) in loop:
            images, labels = images.to(device), labels.to(device)
            optimizer.zero_grad()
            outputs = model(images)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()
            train_loss += loss.item()

            loop.set_description(f"Epoch [{epoch + 1}/{num_epochs}]")
            loop.set_postfix(loss=train_loss / (i + 1))

        train_loss /= len(train_loader)
        val_loss, val_acc, _ = validate(model, val_loader, criterion, device)
        history["train_loss"].append(train_loss)
        history["val_loss"].append(val_loss)
        history["val_acc"].append(val_acc)

        print(f"Epoch [{epoch + 1}/{num_epochs}]")
        print(f"Train loss: {train_loss:.4f}")
        print(f"Validation loss: {val_loss:.4f}")
        print(f"Validation accuracy: {val_acc:.2f}%")

        if val_acc > best_acc:
            best_acc = val_acc
            checkpoint = {
                "epoch": epoch + 1,
                "model": model.state_dict(),
                "optimizer": optimizer.state_dict(),
                "scheduler": scheduler.state_dict(),
                "history": history
            }
            torch.save(checkpoint, "checkpoint.pth")

        scheduler.step()

    return model, history

model, history = train(
    model,
    train_loader,
    val_loader,
    criterion,
    optimizer,
    scheduler,
    device,
    num_epochs=config["model_params"]["num_epochs"]
)

plt.plot(history["train_loss"], label="Train loss")
plt.plot(history["val_loss"], label="Validation loss")
plt.title("Loss curve")
plt.xlabel("Epoch")
plt.ylabel("Loss")
plt.legend()
plt.show()

model.load_state_dict(torch.load("checkpoint.pth")["model"])

_, _, y_pred = validate(model, test_loader, criterion, device)
y_test = [labels for _, labels in test_loader]
y_test = torch.cat(y_test).numpy()

disp = ConfusionMatrixDisplay(confusion_matrix=confusion_matrix(
    y_test, y_pred), display_labels=classes)
disp = disp.plot(xticks_rotation=45)
plt.title('Confusion Matrix Test Data')
plt.show()

print('\n\n')
print(classification_report(y_test, y_pred, target_names=classes))

"""Add a convolution layer followed by a ReLU activation layer just before the flattening step (Architecture 3).  

Run the code.  

Generate the train and validation loss curves.  

Evaluate the model by producing the confusion matrix and other evaluation metrics.  ![image.png](data:image/png;base64,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)
"""

class Cifar10CnnModel(nn.Module):
    """The CIFAR10 CNN model with an additional Conv and ReLU layer before Flatten"""

    def __init__(self, output_size: int) -> None:
        """
        Initialize the CIFAR10 CNN model

        :param output_size: The number of output classes
        :type output_size: int
        """
        super().__init__()
        self.network = nn.Sequential(
            # First Convolutional Block
            nn.Conv2d(3, 32, kernel_size=3, padding=1),
            nn.ReLU(),
            nn.Conv2d(32, 64, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(2, 2),  # Output: 64 x 16 x 16

            # Second Convolutional Block
            nn.Conv2d(64, 128, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.Conv2d(128, 128, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(2, 2),  # Output: 128 x 8 x 8

            # Third Convolutional Block
            nn.Conv2d(128, 256, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.Conv2d(256, 256, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(2, 2),  # Output: 256 x 4 x 4

            # **Additional Convolutional Layer**
            nn.Conv2d(256, 512, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),  # Output: 512 x 4 x 4

            # Flattening Layer
            nn.Flatten(),

            # Fully Connected Layers
            nn.Linear(512 * 4 * 4, 1024),  # Updated input features
            nn.ReLU(),
            nn.Linear(1024, 512),
            nn.ReLU(),
            nn.Linear(512, output_size)
        )
        self._initialize_weights_()

    def _initialize_weights_(self):
        for layer in self.network:
            if isinstance(layer, nn.Linear):
                nn.init.xavier_uniform_(layer.weight)
                nn.init.zeros_(layer.bias)
            elif isinstance(layer, nn.Conv2d):
                nn.init.xavier_uniform_(layer.weight)
                nn.init.zeros_(layer.bias)

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        """
        Forward pass

        :param x: The input data
        :type x: torch.Tensor

        :return: The output logits
        :rtype: torch.Tensor
        """
        return self.network(x)

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

model = Cifar10CnnModel(
    config['model_params']['num_classes']
).to(device)

criterion = torch.nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(
    model.parameters(),
    lr=config["model_params"]["learning_rate"],
    # L2 regularization
    weight_decay=config["model_params"]["weight_decay"]
)
scheduler = torch.optim.lr_scheduler.StepLR(
    optimizer,
    step_size=config["model_params"]["step_size"],
    gamma=config["model_params"]["gamma"]
)

def validate(
    model,
    val_loader: torch.utils.data.DataLoader,
    criterion: torch.nn.Module,
    device: torch.device
) -> tuple:
    """
    Validate the model

    :param model: The model to validate
    :type model: torch.nn.Module
    :param val_loader: The validation loader
    :type val_loader: torch.utils.data.DataLoader
    :param criterion: The loss function
    :type criterion: torch.nn.Module
    :param device: The device to use
    :type device: torch.device

    :return: The loss, accuracy and predictions
    :rtype: tuple
    """
    model.eval()
    val_loss = 0.0
    correct = 0
    y_pred = []
    with torch.no_grad():
        for images, labels in val_loader:
            images, labels = images.to(device), labels.to(device)
            outputs = model(images)
            loss = criterion(outputs, labels)
            val_loss += loss.item()
            _, predicted = torch.max(outputs, 1)
            correct += (predicted == labels).sum().item()
            y_pred.extend(predicted.cpu().numpy())

    val_loss /= len(val_loader)
    accuracy = correct / len(y_pred)

    return val_loss, accuracy, y_pred

def train(
    model: torch.nn.Module,
    train_loader: torch.utils.data.DataLoader,
    val_loader: torch.utils.data.DataLoader,
    criterion: torch.nn.Module,
    optimizer: torch.optim.Optimizer,
    scheduler: torch.optim.lr_scheduler.StepLR,
    device: torch.device,
    num_epochs: int
) -> tuple:
    """
    Train the model

    :param model: The model to train
    :type model: torch.nn.Module
    :param train_loader: The training loader
    :type train_loader: torch.utils.data.DataLoader
    :param val_loader: The validation loader
    :type val_loader: torch.utils.data.DataLoader
    :param criterion: The loss function
    :type criterion: torch.nn.Module
    :param optimizer: The optimizer
    :type optimizer: torch.optim.Optimizer
    :param scheduler: The learning rate scheduler
    :type scheduler: torch.optim.lr_scheduler.StepLR
    :param device: The device to use
    :type device: torch.device
    :param num_epochs: The number of epochs
    :type num_epochs: int

    :return: The trained model and the training history
    :rtype: tuple
    """
    history = {
        "train_loss": [],
        "val_loss": [],
        "val_acc": []
    }
    best_acc = 0.0

    for epoch in range(num_epochs):
        model.train()
        train_loss = 0.0
        loop = tqdm.tqdm(enumerate(train_loader),
                         total=len(train_loader), leave=False)
        for i, (images, labels) in loop:
            images, labels = images.to(device), labels.to(device)
            optimizer.zero_grad()
            outputs = model(images)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()
            train_loss += loss.item()

            loop.set_description(f"Epoch [{epoch + 1}/{num_epochs}]")
            loop.set_postfix(loss=train_loss / (i + 1))

        train_loss /= len(train_loader)
        val_loss, val_acc, _ = validate(model, val_loader, criterion, device)
        history["train_loss"].append(train_loss)
        history["val_loss"].append(val_loss)
        history["val_acc"].append(val_acc)

        print(f"Epoch [{epoch + 1}/{num_epochs}]")
        print(f"Train loss: {train_loss:.4f}")
        print(f"Validation loss: {val_loss:.4f}")
        print(f"Validation accuracy: {val_acc:.2f}%")

        if val_acc > best_acc:
            best_acc = val_acc
            checkpoint = {
                "epoch": epoch + 1,
                "model": model.state_dict(),
                "optimizer": optimizer.state_dict(),
                "scheduler": scheduler.state_dict(),
                "history": history
            }
            torch.save(checkpoint, "checkpoint.pth")

        scheduler.step()

    return model, history

model, history = train(
    model,
    train_loader,
    val_loader,
    criterion,
    optimizer,
    scheduler,
    device,
    num_epochs=config["model_params"]["num_epochs"]
)

plt.plot(history["train_loss"], label="Train loss")
plt.plot(history["val_loss"], label="Validation loss")
plt.title("Loss curve")
plt.xlabel("Epoch")
plt.ylabel("Loss")
plt.legend()
plt.show()

model.load_state_dict(torch.load("checkpoint.pth")["model"])

_, _, y_pred = validate(model, test_loader, criterion, device)
y_test = [labels for _, labels in test_loader]
y_test = torch.cat(y_test).numpy()

disp = ConfusionMatrixDisplay(confusion_matrix=confusion_matrix(
    y_test, y_pred), display_labels=classes)
disp = disp.plot(xticks_rotation=45)
plt.title('Confusion Matrix Test Data')
plt.show()

print('\n\n')
print(classification_report(y_test, y_pred, target_names=classes))

"""Add batch normalization layers to the first two fully connected (FC) layers, placing them just before the sigmoid activation function (Architecture 4).  

Apply batch normalization to each FC layer immediately before the sigmoid activation.  

Run the code.  

Generate the train and validation loss curves.  

Evaluate the model by producing the confusion matrix and other evaluation metrics.  ![image.png](data:image/png;base64,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)

Replaced BatchNorm2d with GroupNorm
"""

import torch
import torch.nn as nn

class Cifar10CnnModel(nn.Module):
    """The CIFAR10 CNN model with additional convolutional and normalization layers."""

    def __init__(self, output_size: int) -> None:
        """
        Initialize the CIFAR10 CNN model with the specified architecture.

        :param output_size: The number of output classes.
        :type output_size: int
        """
        super().__init__()
        self.network = nn.Sequential(
            # First Convolutional Block
            nn.Conv2d(3, 32, kernel_size=3, padding=1),
            nn.GroupNorm(8, 32),    # Replaced BatchNorm2d with GroupNorm
            nn.ReLU(),
            nn.Conv2d(32, 64, kernel_size=3, stride=1, padding=1),
            nn.GroupNorm(16, 64),   # Replaced BatchNorm2d with GroupNorm
            nn.ReLU(),
            nn.MaxPool2d(2, 2),     # Output: 64 x 16 x 16

            # Second Convolutional Block
            nn.Conv2d(64, 128, kernel_size=3, stride=1, padding=1),
            nn.GroupNorm(32, 128),  # Replaced BatchNorm2d with GroupNorm
            nn.ReLU(),
            nn.Conv2d(128, 128, kernel_size=3, stride=1, padding=1),
            nn.GroupNorm(32, 128),  # Replaced BatchNorm2d with GroupNorm
            nn.ReLU(),
            nn.MaxPool2d(2, 2),     # Output: 128 x 8 x 8

            # Third Convolutional Block with Additional Conv and ReLU (Architecture 3)
            nn.Conv2d(128, 256, kernel_size=3, stride=1, padding=1),
            nn.GroupNorm(64, 256),  # Replaced BatchNorm2d with GroupNorm
            nn.ReLU(),
            nn.Conv2d(256, 256, kernel_size=3, stride=1, padding=1),
            nn.GroupNorm(64, 256),  # Replaced BatchNorm2d with GroupNorm
            nn.ReLU(),
            nn.Conv2d(256, 512, kernel_size=3, stride=1, padding=1),  # Added Conv Layer
            nn.GroupNorm(128, 512), # Replaced BatchNorm2d with GroupNorm
            nn.ReLU(),                                           # Added ReLU Layer
            nn.MaxPool2d(2, 2),  # Output: 512 x 4 x 4

            nn.Flatten(),

            # First Fully Connected Layer with Group Normalization (Architecture 4)
            nn.Linear(512 * 4 * 4, 1024),
            nn.GroupNorm(32, 1024),  # Replaced BatchNorm1d with GroupNorm
            nn.ReLU(),
            nn.Dropout(0.5),          # Added Dropout for regularization

            # Second Fully Connected Layer with Group Normalization (Architecture 4)
            nn.Linear(1024, 512),
            nn.GroupNorm(16, 512),   # Replaced BatchNorm1d with GroupNorm
            nn.ReLU(),
            nn.Dropout(0.5),          # Added Dropout for regularization

            # Output Layer
            nn.Linear(512, output_size)
        )
        self._initialize_weights_()

    def _initialize_weights_(self):
        """
        Initialize weights of the network using Xavier uniform initialization for
        linear and convolutional layers, and zero initialization for biases.
        """
        for layer in self.network:
            if isinstance(layer, nn.Linear) or isinstance(layer, nn.Conv2d):
                nn.init.xavier_uniform_(layer.weight)
                if layer.bias is not None:
                    nn.init.zeros_(layer.bias)

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        """
        Forward pass of the model.

        :param x: Input tensor.
        :type x: torch.Tensor

        :return: Output logits.
        :rtype: torch.Tensor
        """
        return self.network(x)

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

model = Cifar10CnnModel(
    config['model_params']['num_classes']
).to(device)

criterion = torch.nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(
    model.parameters(),
    lr=config["model_params"]["learning_rate"],
    # L2 regularization
    weight_decay=config["model_params"]["weight_decay"]
)
scheduler = torch.optim.lr_scheduler.StepLR(
    optimizer,
    step_size=config["model_params"]["step_size"],
    gamma=config["model_params"]["gamma"]
)

def validate(
    model,
    val_loader: torch.utils.data.DataLoader,
    criterion: torch.nn.Module,
    device: torch.device
) -> tuple:
    """
    Validate the model

    :param model: The model to validate
    :type model: torch.nn.Module
    :param val_loader: The validation loader
    :type val_loader: torch.utils.data.DataLoader
    :param criterion: The loss function
    :type criterion: torch.nn.Module
    :param device: The device to use
    :type device: torch.device

    :return: The loss, accuracy and predictions
    :rtype: tuple
    """
    model.eval()
    val_loss = 0.0
    correct = 0
    y_pred = []
    with torch.no_grad():
        for images, labels in val_loader:
            images, labels = images.to(device), labels.to(device)
            outputs = model(images)
            loss = criterion(outputs, labels)
            val_loss += loss.item()
            _, predicted = torch.max(outputs, 1)
            correct += (predicted == labels).sum().item()
            y_pred.extend(predicted.cpu().numpy())

    val_loss /= len(val_loader)
    accuracy = correct / len(y_pred)

    return val_loss, accuracy, y_pred

def train(
    model: torch.nn.Module,
    train_loader: torch.utils.data.DataLoader,
    val_loader: torch.utils.data.DataLoader,
    criterion: torch.nn.Module,
    optimizer: torch.optim.Optimizer,
    scheduler: torch.optim.lr_scheduler.StepLR,
    device: torch.device,
    num_epochs: int
) -> tuple:
    """
    Train the model

    :param model: The model to train
    :type model: torch.nn.Module
    :param train_loader: The training loader
    :type train_loader: torch.utils.data.DataLoader
    :param val_loader: The validation loader
    :type val_loader: torch.utils.data.DataLoader
    :param criterion: The loss function
    :type criterion: torch.nn.Module
    :param optimizer: The optimizer
    :type optimizer: torch.optim.Optimizer
    :param scheduler: The learning rate scheduler
    :type scheduler: torch.optim.lr_scheduler.StepLR
    :param device: The device to use
    :type device: torch.device
    :param num_epochs: The number of epochs
    :type num_epochs: int

    :return: The trained model and the training history
    :rtype: tuple
    """
    history = {
        "train_loss": [],
        "val_loss": [],
        "val_acc": []
    }
    best_acc = 0.0

    for epoch in range(num_epochs):
        model.train()
        train_loss = 0.0
        loop = tqdm.tqdm(enumerate(train_loader),
                         total=len(train_loader), leave=False)
        for i, (images, labels) in loop:
            images, labels = images.to(device), labels.to(device)
            optimizer.zero_grad()
            outputs = model(images)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()
            train_loss += loss.item()

            loop.set_description(f"Epoch [{epoch + 1}/{num_epochs}]")
            loop.set_postfix(loss=train_loss / (i + 1))

        train_loss /= len(train_loader)
        val_loss, val_acc, _ = validate(model, val_loader, criterion, device)
        history["train_loss"].append(train_loss)
        history["val_loss"].append(val_loss)
        history["val_acc"].append(val_acc)

        print(f"Epoch [{epoch + 1}/{num_epochs}]")
        print(f"Train loss: {train_loss:.4f}")
        print(f"Validation loss: {val_loss:.4f}")
        print(f"Validation accuracy: {val_acc:.2f}%")

        if val_acc > best_acc:
            best_acc = val_acc
            checkpoint = {
                "epoch": epoch + 1,
                "model": model.state_dict(),
                "optimizer": optimizer.state_dict(),
                "scheduler": scheduler.state_dict(),
                "history": history
            }
            torch.save(checkpoint, "checkpoint.pth")

        scheduler.step()

    return model, history

model, history = train(
    model,
    train_loader,
    val_loader,
    criterion,
    optimizer,
    scheduler,
    device,
    num_epochs=config["model_params"]["num_epochs"]
)

plt.plot(history["train_loss"], label="Train loss")
plt.plot(history["val_loss"], label="Validation loss")
plt.title("Loss curve")
plt.xlabel("Epoch")
plt.ylabel("Loss")
plt.legend()
plt.show()

model.load_state_dict(torch.load("checkpoint.pth")["model"])

_, _, y_pred = validate(model, test_loader, criterion, device)
y_test = [labels for _, labels in test_loader]
y_test = torch.cat(y_test).numpy()

disp = ConfusionMatrixDisplay(confusion_matrix=confusion_matrix(
    y_test, y_pred), display_labels=classes)
disp = disp.plot(xticks_rotation=45)
plt.title('Confusion Matrix Test Data')
plt.show()

print('\n\n')
print(classification_report(y_test, y_pred, target_names=classes))